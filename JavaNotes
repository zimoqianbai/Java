1.setDefaultCloseOperation():                    是用来设定窗口被关闭时（比如点击了右上角的”x”）的行为。
                                                DISPOSE_ON_CLOSE：隐藏当前窗口，并释放窗体占有的其他资源。在窗口被关闭的时候会dispose这个窗口。
                                               EXIT_ON_CLOSE：结束所有线程，结束窗口所在的应用程序。在窗口被关闭的时候会退出JVM。

2.关于getContentPane()：                        虽然可以在JFrame 对象中添加 AWT 或者 Swing 组件。它有 add 方法，但是却不能直接用于添加组件，
                                                否则会抛出异常。造成这个现象的原因只有一个解释：JFrame 不是一个容器，它只是一个框架。
                                                JFrame 有一个 ContentPane（内容窗格），窗口能显示的所有组件都是添加在这个 ContentPane 中。
                                                JFrame 提供了两个方法：getContentPane 和 setContentPane 就是用于获取和设置其 ContentPane 的。
                                                对JFrame添加组件有两种方式：
　　                                            1)用getContentPane()方法获得JFrame的内容面板，再对其加入组件：Jframe.getContentPane().add(childComponent)

　　                                            2)建立一个Jpanel或JDesktopPane之类的中间容器（把组件添加到容器中）。用setContentPane()方法把该容器置为JFrame的内容面板板

3.类名.class.                                   1.类名.class： JVM将使用类装载器, 将类装入内存(前提是:类还没有装入内存),不做类的初始化工作.返回Class的对象
                                                2.Class.forName("类名字符串")  （注：类名字符串是 包名+类名 ）  说明：装入类,并做类的静态初始化，返回Class的对象
                                                3.实例对象.getClass()  说明：对类进行静态初始化、非静态初始化；返回引用 运行时真正所指的对象(因为:子对象的引用可能会赋给父对象的引用变量)所属的类的Class的对象

4.关于static 和 final：                         【final】
                                                final可以修饰非抽象类、非抽象类成员方法和变量。主要作用是阻止修饰的东西不被改变。
                                               【final修饰的类】不能被继承，final类中的方法默认是被final修饰的。(用于不需要子类的类)
                                               子类继承父类时，父类中【final修饰的方法】不能被子类覆盖（重写），但确实是可以继承父类的这个方法的。
                                                final不能用于修饰构造方法。    P.s.当子类继承父类时，如果不显式的调用super()，则会自动调用父类的无参构造函数
                                                这时，如果父类中已经手动设计了一个有参构造函数，且没有设计一个无参构造函数，子类隐式调用的super()
                                                就调用不到父类的任何构造方法，因为父类手动定义了构造函数，java就回收了默认的无参构造函数。
                                                【final修饰的成员变量】表示常量，只能被赋值一次，赋值后值不能再改变。如果类中的有final变量，
                                                就能保证它的所有子类都使用一致的变量值。
                                                【final参数】 当函数参数为final类型时，你可以读取使用该参数，但是无法改变该参数的值。
 

                                                【static】表示“全局”或者“静态”，用来修饰成员变量和成员方法，也可以形成静态代码块，
                                                被static修饰的成员变量和成员方法独立于类的实例对象，被所有实例共享。只要这个类被加载，JVM就会先执行static修饰的代码
                                                因此，static对象可以在它的任何对象创建之前访问，无需引用任何对象。
                                                用public修饰的static成员变量和成员方法本质是全局变量和全局方法，当创建类的实例对象时，
                                                并不生成static变量的副本，而是类的所有实例共享同一个static变量。
                                                static变量前可以被private修饰，即在类外不可访问，而在类内也只能由静态方法访问
                                                static修饰的成员变量和成员方法习惯上称为静态变量和静态方法，可以直接通过类名来访问
                                                【static变量】
                                                根据是否静态 对类成员变量进行分类可分两种：一种是被static修饰的变量，叫静态变量或类变量；
                                                另一种是没有被static修饰的变量，叫实例变量。两者的区别是：
                                                对于静态变量在内存中只有一个拷贝（节省内存），JVM只为静态分配一次内存，在加载类的过程中完成静态变量的内存分配，可用类名直接访问，
                                                也可以通过对象来访问（但是这是不推荐的）。
                                                对于实例变量，每创建一个实例，就会为实例变量分配一次内存，实例变量可以在内存中有多个拷贝，互不影响（灵活），由对象和自己的实例变量相关联。
                                                【静态方法】
                                                静态方法可以直接通过类名调用，任何的实例也都可以调用，因此静态方法中不能用this和super关键字，
                                                不能访问不带static的成员变量和成员成员方法。因为实例成员是与实例对象相关联的！
                                                由于static方法独立于任何实例，因此static方法必须被实现，而不能是抽象的abstract。
                                                【static代码块】
                                                static代码块也叫静态代码块，是在类中独立于类成员的static语句块，可以有多个，位置可以随便放，它不在任何的方法体内，
                                                JVM加载类时会执行这些静态的代码块，如果static代码块有多个，JVM将按照它们在类中出现的先后顺序依次执行它们，每个代码块只会被执行一次


                                                【static和final】
                                                static final用来修饰成员变量和成员方法，可简单理解为“全局常量”！
                                                对于变量，表示一旦给值就不可修改，并且通过类名可以访问。
                                                对于方法，表示不可覆盖，并且可以通过类名直接访问。
                                                特别要注意一个问题：
                                                对于被static和final修饰过的实例常量，实例本身不能改变，
                                                但对于一些容器类型（比如，ArrayList、HashMap）的实例变量，存放的是引用，不可以改变该引用，但可以修改 引用所指向的容器中 存放的东西
                                          
5.弹出提示框：                                  JOptionPane.showMessageDialog(parentFrame, string text);

6.EventQueue.invokeLater(Runnable runnable)    GUI都是单线程的，如果不主动分派线程，就只能单线程运行，容易发生死锁。
                                               EventQueue类实现异步事件指派机制，将按顺序指派线程，从队列中提取线程，先排队的线程将先被指派。
                                               指派进入队列的事件的唯一要求是： 按顺序指派。也就是说，不允许同时从该队列中指派多个事件。
                                               public static void invokeLater(Runnable runnable)导致 runnable 的 run 方法在 the system EventQueue 的指派线程中被调用。 
                                               invokeLater()方法调用完毕后会被销毁，匿名内部类是作为临时变量存在的，分配的内存在方法调用完毕会被释放
                                               作为匿名内部类，只能被使用依一次，如果是需要重复使用的类不能被写成匿名内部类。

7.swing 布局管理管理器(LayOut)                   FlowLayout按照类似作业纸的方式来安排组件。从左到右，直至没有多余的空间，然后转到下一行，再从左至右。
                                                BorderLayout将界面分成五大区域，分别用BorderLayout类的静态常量指定，上、下、左、右、中
                                                BoxLayout可以将组件由上至下或由左至右，即X或Y方向，叠入容器中，

8.String和byte[]的转换:                          无论是byte[]转String:String tempStr=new String(byteArray);
                                                还是String转byte[]：byte[] byteArray=tempStr.getBytes().都需要查询操作系统默认字符集，中文即GBK进行
                                                进行一一转换。正数与ASCII转换，负数与GBK转换（两个字节对应一个汉字，不可以是单数个。）  
                                                
9.关于String和StringBuffer                       由于String是一个字符串常量，基本上出现一次双引号，就要分配一次内存给字符串常量。如：String str1="abc";str1="abc"+"efg";
                                                 上述例子需要JVM分配三块内存("abc","efg"和"abcefg")，而JVM的运行机制又不能立刻回收无用的内存空间，所以就有了StringBuffer类
                                                 StringBuffer类将实例化一个可变长度的字符数组变量，而不是常量，且分配一块内存，默认的字符长度为16；
                                                 如：StringBuffer sbr1="abc"; str1="abc"+"efg";只分配一块内存。
                                                 并且StringBuffer类操作字符串更加灵活，封装了很多使用的方法。如StringBuffer.append（）//向缓冲区中追加各种类型的值
                                                                                                          StringBuffer.insert()
                                                                                                          StringBuffer.replace（）
                                                                                                          StringBuffer.reverse()
                                                                                                          StringBuffer.toString()
                                                                                                          
9.StringBuffer&StringBuilder                    StringBuilder与StringBuffer使用方法基本相同，他们的区别在于StringBuffer属于线程安全的，因此速度较慢。
                                                StringBuilder属于线程不安全的，有可能不同步，因此运行的速度较快。
                                                所以，二者相较，大多数时间我们应该使用StringBuilder。           

10.关于Collection集合的迭代：                    Collection集合下包含List和Set两类子类，他们又分别有两个子类：List-ArrayList LinkedList
                                                                                                         Set - HashSet  LinkedHashSet
                                               他们都可以使用Colletion的迭代方法获得一个迭代器进行迭代： Iterator  iterator=collection.iterator();
                                               iterator对象实质是对指针的移动，因此，如果在某个循环中通过iterator对集合元素进行遍历，iterator对象
                                               会指向集合的最后一个元素，此时指针的位置已经移动到了集合的尾部，不适合再对该iterator对象进行操作。

11.对于集合迭代的循环方式的选择：                一般是这样的：while(iterator.hasNext()){
                                                                Object obj = iterator.next();
                                                                System.out.println(obj);
                                                           }//但是它的问题是，iterator对象在循环之外的方法中建立的，需要在方法结束后才会被JVM回收，
                                                           因此，使用下面的写法相对节约内存。
                                              节约内存的for写法：
                                              for (Iterator<Object> iterator = collection.iterator(); iterator.hasNext();  ) {
			                                                  System.out.println(it2.next()); 
                                              }//这种写法迭代器对象在循环结束就会被回收
                                                           

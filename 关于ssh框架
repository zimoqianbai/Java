1.NoClassDefFound javax/xml/bind/JAXBException处理方式：
                                                            故障原因：
                                                                  JAXB API是java EE 的API，因此在java SE 9.0 中不再包含这个 Jar 包。 
                                                                  java 9 中引入了模块的概念，默认情况下，Java SE中将不再包含java EE 的Jar包 
                                                                  而在 java 6/7 / 8 时关于这个API 都是捆绑在一起的

                                                            解决方案一：
                                                            降低JDK 9 版本到 JDK 6/7/8

                                                            解决方案二:（亲测可行）

                                                            手动加入这些依赖Jar包

                                                            要解决这个问题，我导入了下面这四个Jar包修复成功。

                                                            javax.activation-1.2.0.jar 
                                                            http://search.maven.org/remotecontent?filepath=com/sun/activation/javax.activation/1.2.0/javax.activation-1.2.0.jar

                                                            jaxb-api-2.3.0.jar 
                                                            http://search.maven.org/remotecontent?filepath=javax/xml/bind/jaxb-api/2.3.0/jaxb-api-2.3.0.jar

                                                            jaxb-core-2.3.0.jar 
                                                            http://search.maven.org/remotecontent?filepath=com/sun/xml/bind/jaxb-core/2.3.0/jaxb-core-2.3.0.jar

                                                            jaxb-impl-2.3.0.jar 
                                                            http://search.maven.org/remotecontent?filepath=com/sun/xml/bind/jaxb-impl/2.3.0/jaxb-impl-2.3.0.jar

                                                            下载上面这些文件和复制他们到libs文件夹下， 
                                                            添加他们导入到Build Path中 
                                                            重新运行即可


                                                            原文地址：https://stackoverflow.com/questions/43574426/how-to-resolve-java-lang-noclassdeffounderror-javax-xml-bind-jaxbexception-in-j
                                                            翻译：https://blog.csdn.net/hadues/article/details/79188793

2.关于将JavaBean的bean属性设置为包装类的意义：                 首先，包装类如Integer如果不赋值，默认是null，但如果是基本类型的全局变量Int（如类字段就是全局的，可以不用初始化。方法中变量是局部的，必须要初始化）,
                                                            不赋值的话，默认值是0；对于一些没有赋值的数据，我们希望持久化到数据库时是Null。因此，使用包装类是很重要的。     
                                                            其次，包装类可以使用一些方法。

3.关于数据操作丢失更新的问题（并发访问）：                      如果两个线程同时访问一条记录，可能前一条记录修改掉了某个字段的值，后一条记录又将其修改了。
                                                            解决方案：
                                                            在javabean中添加一个bean属性private Integer version;{get;set;}
                                                            然后在映射文件XXX.hbm.xml中添加<version name="version">即可
                                                            hibernate会在更新提交时比对version前后是否一致再决定是否执行更新
                                                            
4.关于hibernate级联保存：                                    如果在customer端设置级联cascade="save-update"，save-update：（如果数据库中有更新，没有就保存）
                                                            只要操作customer添加联系人，保存customer就可以级联保存联系人
                                                            
                                                            如果在linkman端设置级联cascade="save-update"
                                                            只要操作linkman.setCustomer(customer)，再保存session.save(linkman)就可以级联保存customer 
                                                            如果session.save多条Linkman,也只有第一次会保存customer,之后的都是更新customer语句（save-update）
          
                                                            如果两端都配置了级联保存
                                                            就看session.save的时候保存的对象是否有关联，只要有关联的都可以保存进数据库。
                                                            如linkman1.setCustomer(customer1),
                                                            customer1.getLinkmans().add(linkman2)
                                                            session.save(linkman1);//customer表中一条数据customer1且linkman表中两条数据linkman1和2
                                                            
5.

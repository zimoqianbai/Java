1.NoClassDefFound javax/xml/bind/JAXBException处理方式：
                                                            故障原因：
                                                                  JAXB API是java EE 的API，因此在java SE 9.0 中不再包含这个 Jar 包。 
                                                                  java 9 中引入了模块的概念，默认情况下，Java SE中将不再包含java EE 的Jar包 
                                                                  而在 java 6/7 / 8 时关于这个API 都是捆绑在一起的

                                                            解决方案一：
                                                            降低JDK 9 版本到 JDK 6/7/8

                                                            解决方案二:（亲测可行）

                                                            手动加入这些依赖Jar包

                                                            要解决这个问题，我导入了下面这四个Jar包修复成功。

                                                            javax.activation-1.2.0.jar 
                                                            http://search.maven.org/remotecontent?filepath=com/sun/activation/javax.activation/1.2.0/javax.activation-1.2.0.jar

                                                            jaxb-api-2.3.0.jar 
                                                            http://search.maven.org/remotecontent?filepath=javax/xml/bind/jaxb-api/2.3.0/jaxb-api-2.3.0.jar

                                                            jaxb-core-2.3.0.jar 
                                                            http://search.maven.org/remotecontent?filepath=com/sun/xml/bind/jaxb-core/2.3.0/jaxb-core-2.3.0.jar

                                                            jaxb-impl-2.3.0.jar 
                                                            http://search.maven.org/remotecontent?filepath=com/sun/xml/bind/jaxb-impl/2.3.0/jaxb-impl-2.3.0.jar

                                                            下载上面这些文件和复制他们到libs文件夹下， 
                                                            添加他们导入到Build Path中 
                                                            重新运行即可


                                                            原文地址：https://stackoverflow.com/questions/43574426/how-to-resolve-java-lang-noclassdeffounderror-javax-xml-bind-jaxbexception-in-j
                                                            翻译：https://blog.csdn.net/hadues/article/details/79188793

2.关于将JavaBean的bean属性设置为包装类的意义：                 首先，包装类如Integer如果不赋值，默认是null，但如果是基本类型的全局变量Int（如类字段就是全局的，可以不用初始化。方法中变量是局部的，必须要初始化）,
                                                            不赋值的话，默认值是0；对于一些没有赋值的数据，我们希望持久化到数据库时是Null。因此，使用包装类是很重要的。     
                                                            其次，包装类可以使用一些方法。

3.关于数据操作丢失更新的问题（并发访问）：                      如果两个线程同时访问一条记录，可能前一条记录修改掉了某个字段的值，后一条记录又将其修改了。
                                                            解决方案：
                                                            在javabean中添加一个bean属性private Integer version;{get;set;}
                                                            然后在映射文件XXX.hbm.xml中添加<version name="version">即可
                                                            hibernate会在更新提交时比对version前后是否一致再决定是否执行更新
                                                            
4.关于hibernate级联保存：                                    如果在customer端设置级联cascade="save-update"，save-update：（如果数据库中有更新，没有就保存）
                                                            只要操作customer添加联系人，保存customer就可以级联保存联系人
                                                            
                                                            如果在linkman端设置级联cascade="save-update"
                                                            只要操作linkman.setCustomer(customer)，再保存session.save(linkman)就可以级联保存customer 
                                                            如果session.save多条Linkman,也只有第一次会保存customer,之后的都是更新customer语句（save-update）
          
                                                            如果两端都配置了级联保存
                                                            就看session.save的时候保存的对象是否有关联，只要有关联的都可以保存进数据库。
                                                            如linkman1.setCustomer(customer1),
                                                            customer1.getLinkmans().add(linkman2)
                                                            session.save(linkman1);//customer表中一条数据customer1且linkman表中两条数据linkman1和2
                                                            
5.使用structs2框架时碰到了两个错误：                          java.nio.file.InvalidPathException: Illegal char <:> at index 3: jar:file:\C:\Program%20Files\Java\apache-tomcat-9.0.5\webapps\day32\WEB-INF\lib\struts2-core-2.3.24.jar
                                                            这个是版本问题，我使用的是tomcat9和jdk9,必须要最新的struts-2.5.16
然后又遇到一个新的错误，直接404访问不到项目下的任何目录：        这个是新版本的问题，试一试下面几个配置：
                                                             1、 <!DOCTYPE struts PUBLIC  
                                                                "-//Apache Software Foundation//DTD Struts Configuration 2.3//EN"  
                                                                "http://struts.apache.org/dtds/struts-2.3.dtd">   <!--2.5版本的要改为2.5--></span>  
                                                            2、 <!-- 开启动态方法调用，升级strust2 2.3.32时需要配置这个 -->  
                                                                <constant name="struts.enable.DynamicMethodInvocation" value="true"/></span>  
                                                            3、配置2.5版本需要JDK1.7，还需要注意web.xml配置
                                                                     <!-- 2.5版本的filter配置 -->  
                                                                    <filter-name>struts2</filter-name>  
                                                                    <filter-class>org.apache.struts2.dispatcher.filter.StrutsPrepareAndExecuteFilter</filter-class></span>  
                                                            4、2.5版本的404报错问题，需要在struts.xml配置
                                                            <!--   配置2.5版本，struts.xml需要配置，需要放在package里面并且在第一个action配置的前面 -->  
                                                                 <global-allowed-methods>regex:.*</global-allowed-methods></span>  


